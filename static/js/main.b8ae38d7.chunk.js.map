{"version":3,"sources":["components/Block.tsx","components/Score.tsx","move.tsx","App.tsx","index.tsx"],"names":["GameBlock","styled","div","Block","item","style","background","getColors","color","num","GameScore","Score","name","score","pushNumber","pushGrid","blankGrid","i","length","j","push","getBlankGrid","randomPush","Math","floor","random","leftPush","inputGrid","returnGrid","addScore","row","empty_count","nowNumber","moveLeft","moveGrid","_","moveLeftGrid","moveRight","reverse","moveRightGrid","moveUp","transpose","moveUpGrid","moveDown","moveDownGrid","matrix","column","temp","Board","Retry","App","useState","grid","setGrid","gameOver","setGameOver","setScore","best","setBest","swipe","setSwipe","useEffect","newGrid","isGameOver","JSON","stringify","playGame","where","newLeftGrid","prev","newRightGrid","newUpGrid","newDownGrid","onSwipeMove","position","abs","x","y","onKeyDown","e","keyCode","tabIndex","display","justifyContent","fontSize","fontWeight","margin","alignItems","onClick","initGrid","innerRef","ref","setTimeout","map","rowIndex","itemIndex","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b8ae38d7.chunk.js","sourcesContent":["import styled from 'styled-components';\n\nconst GameBlock = styled.div`\n  height: 80px;\n  width: 80px;\n  background: lightgray;\n  margin: 3px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-size: 45px;\n  font-weight: 800;\n  color: white;\n  padding: 5px;\n`;\n\ninterface IBlockProps {\n  item: number;\n}\n\nconst Block: React.FC<IBlockProps> = ({ item }) => {\n  return (\n    <GameBlock\n      style={{\n        background: getColors(item),\n        color: item === 2 || item === 4 ? `#645B52` : `#F7F4EF`,\n      }}\n    >\n      {item ? item : ''}\n    </GameBlock>\n  );\n};\n\nexport default Block;\n\nconst getColors = (num: any) => {\n  switch (num) {\n    case 2:\n      return '#EDE4DA';\n    case 4:\n      return '#EEE1C9';\n    case 8:\n      return '#F3B279';\n    case 16:\n      return '#F79563';\n    case 32:\n      return '#F2654F';\n    case 64:\n      return '#F75F3B';\n    case 128:\n      return '#EDD073';\n    case 256:\n      return '#EECC61';\n    case 512:\n      return '#EDC950';\n    case 1024:\n      return '#E8BB31';\n    case 2048:\n      return '#E7B723';\n    case 4096:\n      return '#2385D0';\n    case 8192:\n      return '#000000';\n    default:\n      return '#C2B3A3';\n  }\n};\n","import styled from 'styled-components';\n\nconst GameScore = styled.div`\n  display: flex;\n  align-items: center;\n  margin-bottom : 3px\n  padding-top: 7px;\n  padding-botton: 7px;\n  padding-left: 10px;\n  padding-right: 10px;\n  background: #846f5b;\n  color: #f8f5f0;\n  width: 50px;\n  font-weight: 900;\n  margin-left: 5px;\n  margin-bottom: auto;\n`;\n\ninterface IScoreProps {\n  score: number;\n  name: string;\n}\n\nconst Score: React.FC<IScoreProps> = ({ name, score }) => {\n  return (\n    <GameScore>\n      {name}\n      <br></br>\n      {score}\n    </GameScore>\n  );\n};\n\nexport default Score;\n","import * as _ from 'lodash';\n// 게임판에서 비어있는 공간을 찾는다.\nexport const getBlankGrid = (pushGrid: number[][]) => {\n  const blankGrid: number[][] = [];\n\n  for (let i = 0; i < pushGrid.length; i++) {\n    for (let j = 0; j < pushGrid[i].length; j++) {\n      if (pushGrid[i][j] === 0) {\n        blankGrid.push([i, j]);\n      }\n    }\n  }\n  return blankGrid;\n};\n\n// 게임판이 꽉 찼다면 그냥 그대로 반환\nexport const pushNumber = (pushGrid: number[][]) => {\n  const blankGrid: number[][] = getBlankGrid(pushGrid);\n  const randomPush: number[] =\n    blankGrid[Math.floor(Math.random() * blankGrid.length)];\n  const pushNumber = Math.random() > 0.5 ? 2 : 4;\n\n  pushGrid[randomPush[0]][randomPush[1]] = pushNumber;\n  return pushGrid;\n};\n\nexport const leftPush = (inputGrid: number[][]) => {\n  let returnGrid: number[][] = [];\n  let addScore: number = 0;\n  // 한쪽으로 몰아넣기\n  // 비어있는 것(0)이 있다면 row에 넣지 않고, 나머지는 넣는다.\n  // 이때 0의 개수를 count하고 나중에 그만큼 row에 push\n  for (let i = 0; i < inputGrid.length; i++) {\n    let row = [];\n    let empty_count = 0;\n    for (let j = 0; j < inputGrid[i].length; j++) {\n      let nowNumber = inputGrid[i][j];\n      if (nowNumber !== 0) {\n        row.push(nowNumber);\n      } else {\n        empty_count++;\n      }\n    }\n    // 0이 있던만큼 다시 0을 넣어준다.\n    for (let j = 0; j < empty_count; j++) {\n      row.push(0);\n    }\n    returnGrid.push(row);\n  }\n\n  // 같은 숫자가 있다면 결합하기\n  // [4,4,4,4], [4,2,2,0], [4,4,2,0], [4,2,4,4] 의 4가지 경우가 존재.\n  // 0의 경우는 신경쓰지 않아도 된다. 어차피 위에서 다 한쪽으로 몰아놔서 신경x\n  for (let i = 0; i < returnGrid.length; i++) {\n    // [4,4,4,4] 의 경우. 2개씩 짝을 이루어서 합쳐지는 것이 가능할때\n    if (\n      returnGrid[i][0] === returnGrid[i][1] &&\n      returnGrid[i][2] === returnGrid[i][3]\n    ) {\n      returnGrid[i][0] = returnGrid[i][0] * 2;\n      returnGrid[i][1] = returnGrid[i][2] * 2;\n      returnGrid[i][2] = 0;\n      returnGrid[i][3] = 0;\n      addScore = addScore + returnGrid[i][0] + returnGrid[i][1];\n    }\n    // [4,4,2,0] [4,4,0,0], [4,4,2,4] 의 경우\n    else if (returnGrid[i][0] === returnGrid[i][1]) {\n      returnGrid[i][0] = returnGrid[i][0] * 2;\n      returnGrid[i][1] = returnGrid[i][2];\n      returnGrid[i][2] = returnGrid[i][3];\n      returnGrid[i][3] = 0;\n      addScore = addScore + returnGrid[i][0];\n    }\n    // [4,2,2,0], [4,2,2,4]\n    else if (returnGrid[i][1] === returnGrid[i][2]) {\n      returnGrid[i][1] = returnGrid[i][1] * 2;\n      returnGrid[i][2] = returnGrid[i][3];\n      returnGrid[i][3] = 0;\n      addScore = addScore + returnGrid[i][1];\n    }\n    // [4,2,4,4] 의 경우\n    else if (returnGrid[i][2] === returnGrid[i][3]) {\n      returnGrid[i][2] = returnGrid[i][2] * 2;\n      returnGrid[i][3] = 0;\n      addScore = addScore + returnGrid[i][2];\n    }\n  }\n\n  return { returnGrid, addScore };\n};\n// 왼쪽으로 이동시키고, 값을 더한 Grid를 return.\nexport const moveLeft = (inputGrid: number[][]) => {\n  let moveGrid: number[][] = _.cloneDeep(inputGrid);\n  const { returnGrid, addScore } = leftPush(moveGrid);\n  const moveLeftGrid = _.cloneDeep(returnGrid);\n  return { moveLeftGrid, addScore };\n};\n\n// 오른쪽으로 이동시키고, 값을 더한 Grid를 return.\nexport const moveRight = (inputGrid: number[][]) => {\n  let moveGrid: number[][] = _.cloneDeep(inputGrid);\n  // 배열을 뒤집어준다.\n  moveGrid = reverse(moveGrid);\n  // 왼쪽으로 몰아주는 함수\n  const { returnGrid, addScore } = leftPush(moveGrid);\n  moveGrid = _.cloneDeep(returnGrid);\n  // 배열을 다시 뒤집는다.\n  const moveRightGrid = reverse(moveGrid);\n  return { moveRightGrid, addScore };\n};\n\n// 시계방향으로 회전시키고, moveRight 한다음에 다시 반시계 회전시키면 된다.\nexport const moveUp = (inputGrid: number[][]) => {\n  let moveGrid: number[][] = _.cloneDeep(inputGrid);\n  // 배열을 반시계방향으로 회전시킨다.\n  moveGrid = transpose(reverse(moveGrid));\n  // 왼쪽으로 몰아주는 함수\n  const { returnGrid, addScore } = leftPush(moveGrid);\n  moveGrid = _.cloneDeep(returnGrid);\n  // 배열을 다시 시계방향으로 회전시킨다.\n  const moveUpGrid = reverse(transpose(moveGrid));\n  return { moveUpGrid, addScore };\n};\n\nexport const moveDown = (inputGrid: number[][]) => {\n  let moveGrid: number[][] = _.cloneDeep(inputGrid);\n  // 배열을 시계방향으로 회전시킨다.\n  moveGrid = reverse(transpose(moveGrid));\n  // 왼쪽으로 몰아주는 함수\n  const { returnGrid, addScore } = leftPush(moveGrid);\n  moveGrid = _.cloneDeep(returnGrid);\n  // 배열을 다시 반시계방향으로 회전시킨다.\n  const moveDownGrid = transpose(reverse(moveGrid));\n  return { moveDownGrid, addScore };\n};\n\n// 배열을 대각선으로 접는다.\nexport const transpose = (matrix: number[][]) => {\n  for (let row = 0; row < matrix.length; row++) {\n    for (let column = 0; column < row; column++) {\n      let temp = matrix[row][column];\n      matrix[row][column] = matrix[column][row];\n      matrix[column][row] = temp;\n    }\n  }\n  return matrix;\n};\n// 배열 요소들 반대로\nexport const reverse = (matrix: number[][]) => {\n  for (let i = 0; i < matrix.length; i++) {\n    matrix[i].reverse();\n  }\n  return matrix;\n};\n","import styled from 'styled-components';\n\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport Swipe from 'react-easy-swipe';\nimport Block from './components/Block';\nimport Score from './components/Score';\nimport { pushNumber, moveLeft, moveRight, moveDown, moveUp } from './move';\n\n// 해야할 것\nconst Board = styled.div`\n  background: #ad9d8f;\n  width: max-content;\n  margin: auto;\n  padding: 5px;\n  border-radius: 5px;\n  margin-top: 5px;\n`;\n\nconst Retry = styled.div`\n  display: flex;\n  justify-content: center;\n  padding: 10px;\n  background: #846f5b;\n  color: #f8f5f0;\n  width: 50px;\n  border-radius: 7px;\n  font-weight: 900;\n  margin-left: auto;\n  margin-bottom: auto;\n  cursor: pointer;\n`;\n\nconst App: React.FC = () => {\n  // 버튼 한번을 누르면 전체가 바뀌기 때문에 그냥 하나의 state에서 grid를 관리\n  // 또한 나중에 게임을 하면서 이동했는지 안했는지 비교할때 전체가 필요하기 때문에\n  // 판 전체를 관리한다\n  const [grid, setGrid] = useState<number[][]>([\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n  ]);\n  const [gameOver, setGameOver] = useState<boolean>(false);\n  const [score, setScore] = useState<number>(0);\n  const [best, setBest] = useState<number>(0);\n  const [swipe, setSwipe] = useState<boolean>(false);\n\n  useEffect(() => {\n    let newGrid: number[][] = [\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n    ];\n    setScore(0);\n    newGrid = pushNumber(pushNumber(newGrid));\n    setGrid(newGrid);\n  }, []);\n\n  const initGrid = () => {\n    let newGrid: number[][] = [\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n    ];\n    if (gameOver === true) {\n      setGameOver(false);\n    }\n    setScore(0);\n    setSwipe(false);\n    // 처음에 2번 넣는다.\n    newGrid = pushNumber(pushNumber(newGrid));\n    setGrid(newGrid);\n  };\n\n  // 오른쪽 왼쪽 위 아래 모두 이동시켜보았을때 이전의 gird랑 같으면 더이상 움직일 수 없다는 것\n  const isGameOver = (inputGrid: number[][]) => {\n    if (\n      JSON.stringify(moveLeft(inputGrid).moveLeftGrid) !==\n      JSON.stringify(inputGrid)\n    ) {\n      return false;\n    }\n    if (\n      JSON.stringify(moveRight(inputGrid).moveRightGrid) !==\n      JSON.stringify(inputGrid)\n    ) {\n      return false;\n    }\n    if (\n      JSON.stringify(moveUp(inputGrid).moveUpGrid) !== JSON.stringify(inputGrid)\n    ) {\n      return false;\n    }\n    if (\n      JSON.stringify(moveDown(inputGrid).moveDownGrid) !==\n      JSON.stringify(inputGrid)\n    ) {\n      return false;\n    }\n\n    return true;\n  };\n\n  const playGame = (where: string) => {\n    if (gameOver === false) {\n      switch (where) {\n        case 'left':\n          const moveLeftGrid = moveLeft(grid);\n          if (\n            JSON.stringify(grid) !== JSON.stringify(moveLeftGrid.moveLeftGrid)\n          ) {\n            // 여기에 들어와있다는 것은 반드시 빈칸이 존재한다는 것을 의미한다.\n            const newLeftGrid = pushNumber(moveLeftGrid.moveLeftGrid);\n\n            if (isGameOver(newLeftGrid)) {\n              setGameOver(true);\n              if (score > best) {\n                setBest(score);\n              }\n            }\n            setScore((prev) => prev + moveLeftGrid.addScore);\n            setGrid(newLeftGrid);\n          }\n          break;\n        case 'right':\n          const moveRightGrid = moveRight(grid);\n          if (\n            JSON.stringify(grid) !== JSON.stringify(moveRightGrid.moveRightGrid)\n          ) {\n            // 여기에 들어와있다는 것은 반드시 빈칸이 존재한다는 것을 의미한다.\n            const newRightGrid = pushNumber(moveRightGrid.moveRightGrid);\n\n            if (isGameOver(newRightGrid)) {\n              if (score > best) {\n                setBest(score);\n              }\n              setGameOver(true);\n            }\n            setScore((prev) => prev + moveRightGrid.addScore);\n            setGrid(newRightGrid);\n          }\n          break;\n        case 'up':\n          const moveUpGrid = moveUp(grid);\n          if (JSON.stringify(grid) !== JSON.stringify(moveUpGrid.moveUpGrid)) {\n            // 여기에 들어와있다는 것은 반드시 빈칸이 존재한다는 것을 의미한다.\n            const newUpGrid = pushNumber(moveUpGrid.moveUpGrid);\n\n            if (isGameOver(newUpGrid)) {\n              setGameOver(true);\n              if (score > best) {\n                setBest(score);\n              }\n            }\n            setScore((prev) => prev + moveUpGrid.addScore);\n            setGrid(newUpGrid);\n          }\n          break;\n        case 'down':\n          const moveDownGrid = moveDown(grid);\n          if (\n            JSON.stringify(grid) !== JSON.stringify(moveDownGrid.moveDownGrid)\n          ) {\n            // 여기에 들어와있다는 것은 반드시 빈칸이 존재한다는 것을 의미한다.\n            const newDownGrid = pushNumber(moveDownGrid.moveDownGrid);\n\n            if (isGameOver(newDownGrid)) {\n              setGameOver(true);\n              if (score > best) {\n                setBest(score);\n              }\n            }\n            setScore((prev) => prev + moveDownGrid.addScore);\n            setGrid(newDownGrid);\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  };\n\n  const handleKeyDown = (e: any) => {\n    const left = 37;\n    const right = 39;\n    const up = 38;\n    const down = 40;\n    if (e.keyCode === left) {\n      playGame('left');\n    } else if (e.keyCode === right) {\n      playGame('right');\n    } else if (e.keyCode === up) {\n      playGame('up');\n    } else if (e.keyCode === down) {\n      playGame('down');\n    }\n  };\n\n  const swipeMove = (position: any) => {\n    if (swipe === false) {\n      setSwipe(true);\n      onSwipeMove(position);\n      setTimeout(() => setSwipe(false), 200);\n    }\n  };\n  const onSwipeMove = (position: any) => {\n    if (Math.abs(position.x) > Math.abs(position.y)) {\n      if (position.x > 0) {\n        playGame('right');\n      } else if (position.x < 0) {\n        playGame('left');\n      }\n    } else {\n      if (position.y < 0) {\n        playGame('up');\n      } else if (position.y > 0) {\n        playGame('down');\n      }\n    }\n  };\n  return (\n    <>\n      <Board onKeyDown={handleKeyDown} tabIndex={1}>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div style={{ fontSize: '50px', fontWeight: 'bold', margin: '0' }}>\n            MY 2048\n          </div>\n          <div\n            style={{\n              display: 'flex',\n              justifyContent: 'space-between',\n              alignItems: 'center',\n            }}\n          >\n            <Score name=\"score\" score={score} />\n            <Score name=\"best\" score={best} />\n          </div>\n        </div>\n        <Retry onClick={() => initGrid()}>retry</Retry>\n        <Swipe innerRef={(ref) => ref} onSwipeMove={swipeMove}>\n          {grid.map((row, rowIndex) => (\n            <div style={{ display: 'flex' }} key={`rowIndex-${rowIndex}`}>\n              {row.map((item: any, itemIndex) => (\n                <Block key={`itemIndex-${itemIndex}`} item={item} />\n              ))}\n            </div>\n          ))}\n        </Swipe>\n      </Board>\n      <p>{gameOver ? 'Game Over!! push retry' : ''}</p>\n    </>\n  );\n};\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}